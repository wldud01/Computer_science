## 다양한 입출력의 방법

### 프로그램 입출력

프로그램 속 명령어로 입출력 장치를 제어하는 방법이다.

입출력 명령어로써 장치 컨트롤러와 상호작용 한다.

메모리에 저장된 정보를 하드디스크에 백업한다고 했을 때 하드디스크에 새로운 정보를 쓰게 된다. 

1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령어를 내보낸다.
2. 하드 디스크 컨트롤러는 하드디스크 상태를 확인한다. 그리고 상태 레지스터에 준비 완료를 표시한다.
3. 준비가 되었으면 CPU가 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인한다.
4. 하드 디스크가 준비되었다면 백업할 메모리의 정보를 데이터 레지스터에 쓴다.
5. 백업 작업이 끝나지 않으면 계속 준비 확인과 데이터 레지스터 과정을 반복한다.

정리를 하면 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어진다. 근데 다양한 입출력 장치를 어떻게 규격화 할 수 있었을까?

어떻게 명령어가 표현되고 메모리에 저장될까?

- 메모리 맵 입출력
    
    메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간을 간주하는 방법
    
    주소 공간이 있다고 할 때 메모리를 위한 주소 공간도 있고 입출력 장치가 쓰기 위한 주소 공간도 있다는 의미이다
    
    만약 번지수로 입출력 장치의 컨트롤러의 레지스터를 정의했다고 가정하면, 해당 입출력 장치의 상태를 읽어오기 위해서 해당 번지를 가지고 명령을 하면 된다. 즉 입출력에게 하는 명령어와 메모리에 하는 명령어가 같다고 할 수 있다.
    
    메모리 주소 공간이 축소된다.
    
- 고립형 입출력
    
    메모리 맵 입출력과 다르게 두 공간을 분리하는 방법이다. 입출력 전용 공간이 존재한다. 즉 입출력 전용 명령어가 따로 있다는 것이다. 
    
    제어 버스 뿐만 아니라 입출력 장치 읽기 쓰기 선이 따로 있다. 
    
    메모리 주소 공간이 축소되지 않는다.
    

### 인터럽트 기반 입출력

- 하드웨어 인터럽트의 개념
    
    장치 컨트롤러에 의해 발생하게 된다. CPU가 장치 컨트롤러에 명령을 하게 되고 인터럽트 요청을 장치 컨트롤러가 CPU에 하게 된다.
    
    하드디스크에서 준비 상태로 지속적으로 확인하지 않아도 인터럽트를 통해서 확인할 수 있다.
    
    인터럽트 요청은 프로그램을 많이 사용하게 되면 다양한 인터럽트 요청이 동시 다발적으로 일어나게 된다. 
    
    그럼 CPU가 많은 인터럽트 요청 신호를 받게 되는데 어떻게 처리하게 될까?
    
    보통 순차적으로 처리할 수도 있는데 NMI ( Non-masked interrupt 하드웨어가 고장나는 경우)의 경우 플래그 레지스터 속 인터럽트 비트를 비활성화 해도 순차적으로 인터럽트를 처리할 수 없는 위험한 인터럽트에 경우 처리할 수 밖에 없다.
    
    그런데 동시 다발적으로 인터럽트가 발생했을 때 모두 순차적으로 처리하기는 어렵다. 더 빨리 처리해야 하는 인터럽트가 있다. 
    
    우선순위가 높은 인터럽트가 생기게 되는데 우선순위를 반영해서 다중 인터럽트를 처리하게 된다, 대표적으로는 PIC(programmable Interrupt Controller)가 있다. 여러 장치 컨트롤러에 연결되어 우선순위를 판단한 뒤CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어이다. CPU와 장치컨트롤러 사이에서 처리하는 하드웨어로 여러 개를 같이 사용하는 경우가 많다. 
    

### DMA 입출력

이제까지 알아본 프로그램 입출력과 인터럽트 기반 입출력의 공통점은 일단 입출력 장치와 메모리 간의 데이터 이동은 CPU가 주도하고 이동하는 데이터도 반드시 CPU를 거친다.. 라는 점이다. 

근데 CPU는 하는 일이 많은 상황에서 하드디스크백업과 같이 대용량 데이터를 이동 해야 한다면 어떻게 해야 할까? 

이러한 문제를 해결하기 위해서 DMA (Direct Memory Access)를 도입한다. 이는 CPU를 거치지 않고 입출력 장치가 메모리에 직접적으로 접근하는 기능이다. 

마찬가지로 DMA 컨트롤러가 필요하다. 입출력 과정은 DMA 컨트롤러에게 명령을 하게 되고 DMA 컨트롤러가  메모리에 직접적으로 접근해서 직접 읽고 쓸 수 있게 된다. 일이 끝나면 CPU에게 인터럽트를 통해서 일이 끝났음을 알리게 된다. 그럼 그동안 CPU는다른 일을 할 수 있게 된다.  

그럼 CPU은 입출력 작업의 시작과 끝만 관여하게 된다. 메모리는 시스템 버스에 연결되어 있고 DMA 컨트롤러는 시스템 버스를 이용하게 된다. 그런데 시스템 버스는 공용 자원이기 때문에 동시에 사용은 불가능하다. 

따라서 CPU가 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 이용하게 된다. 서로 배려하면서 사용한다고 생각하면 될 것 같다.

 이를 cycle stealing이라고 한다.

 그런데 DMA는 시스템 버스와 직접적으로 연결되어 있을까? 만약 연결되어 있다면 접근할 때 한번 읽어드릴 때 한번 즉 두 번이나 접근해야 한다. 이런 불필요한 문제를 방지하기 위해서 입출력 전용 버스에 연결되게 된다.

입출력 버스에 대한 개념이 나오게 된 계기가 DMA의 시스템 버스 점유를 방지하기 위해서 이다. 

입출력 버스는 PCI 버스가 대표적으로 있다.

슬롯 → 입출력 버스 → 시스템 버스

최근에는 입출력 전용 프로세서를 탑재한 시스템도 나왔다..
