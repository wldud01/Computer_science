## 프로세스 상태와 계층 구조

- 작업 관리자 → 세부 정보 → 상태
    
    PCB에 기록되는 프로세스 상태
    

### 프로세스 상태

많은 운영체제가 존재하고 운영체제마다 조금씩 다르지만 대표적인 상태가 존재한다

- 생성 상태
    
    프로세스가 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
    
    준비가 완료되었다면 준비 상태로 될 수 있다
    
- 준비 상태
    
    당장이라도 CPU를 할당 받아 실행 할 수 있지만 자신의 차례가 아니기 때문에 기다리는 상태이다
    
    즉 자신의 차례가 되면 바로 실행이 가능하다 → 디스 패치라고 한다
    
- 실행 상태
    
    실행 상태는 CPU를 할당 받아서 실행 중이 상태이다
    
    할당된 시간을 모두 사용되어 타이머 인터럽트가 발생하면 준비 상태로 다시 돌아간다
    
    실행 도중에 입출력 장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로 되어 있다. → 입출력 완료 인터럽트를 받을 때까지 대기
    
- 대기 상태
    
    프로세스가 실행 도중 입출력 장치를 사용하는 경우
    
    입출력 작업은 cpu에 비해 느리기 때문에 이 경우 대기 상태로 접어든다
    
    입출력 작업이 끝나면 준비 상태로 돌아간다 → 입출력 완료 인터럽트를 받았다
    
- 종료 상태
    
    프로세스 종료된 상태
    
    PCB 블록 메모리 영역을 정리 한다
    

### 프로세스의 계층 구조

윈도우 운영체제는 계층 구조로 관리하지 않지만 알아야 할 내용이다

프로세스 실행 도중에 시스템 호출을 통해 다른 프로세스 생성이 가능하다

- 새 프로세스를 생성한 프로세스 → 부모 프로세스
- 부모 프로세스에 의해 생성된 프로세스 → 자식 프로세스

두 개는 별개의 프로세스 이기 때문에 다른 PID를 갖는다

일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID를 명시하기도 한다

자식 프로세스 또한 자식 프로세스를 계속 낳을 수 있다. 즉 계층적인 구조를 가지게 된다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c8e9c980-8f8d-482e-b09b-c51220d818af/87282264-5ba5-46ba-b2ad-56ba1afd64cd/Untitled.png)

최초의 프로세스를 간단한 명령어로 확인할 수 있다

```jsx
# 리눅스
pstree
```

### 프로세스 생성 기법

부모 프로세스는 자식 프로세스를 어떻게 만들어 내고 자식 프로세스는 어떻게 자신만의 코드를 실행할 수 있을까?

각각 프로세스가 메모리에 각각 저장되어 있을 것이다. 그런데 어떻게 위와 같은 질문이 가능할까?

많은 운영체제에서는 복제와 옷 갈아 입기가 가능하다

부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 자식 프로세스를 생성(복제)

자식 프로세스는 exec 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 교체한다(옷 갈아 입기)

- fork
    
    복사본 생성 ( 완전한 복제본이지만 다른 프로세스이기 때문에 고유의 PID를 부여 받는다.)
    
    자식 프로세스 생성
    
    부모 프로세스의 자원 상속
    
- exec 시스템 호출
    
    메모리 공간을 새로운 프로그램으로 덮어쓰기
    
    코드 데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화가 된다.
    

부모 fork → 자식 프로세스 ( 완전히 부모 프로세스와 동일) → exec → 완전히 새로운 프로세스 ( 부모 프로세스와 완전히 다름)

예를 들면 bash에서 자식 프로세스인 vim을 생성하고 vim에서 q라는 새로운 명령어를 했을 때 exec가 실행되어 q 명령어를 실행하기 위한 완전히 새로운 프로세스가 생성된다.

그래서 프로세스 계층 구조는 부모 프로세스와 자식 프로세스의 fork와 exec의 반복이라고 할 수 있다.
